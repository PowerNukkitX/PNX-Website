# 初步了解生物AI架构

## 简介

PNX提供了一个完整的，高性能的，可扩展性强的，易上手的生物AI框架，整体架构借鉴了JE。

通过PNX提供的生物AI框架，你可以高效而简单的开发出自己的AI逻辑。

## 关于性能

测试机器硬件参数如下 (不同配置的机器实测结果可能不同)：

#### CPU:
![CPU INFO](%relativePrefix%image/entity-ai/cpu-info.png)

#### RAM:
![RAM INFO](%relativePrefix%image/common/entity-ai/ram-info.png)  

我们使用超平坦进行测试，测试方法为比较相同羊数量的情况下的TPS（PNX中的羊AI拥有原版所有行为）。相同条件下与BDS的性能比较如下：

![PNX VS BDS](%relativePrefix%image/common/entity-ai/pnx-vs-bds.png)

实测PNX在超平坦条件下可以在承载高达2600只羊的情况下以20TPS的速率运行（事实上在这个数量下客户端已经非常卡顿了）

## 基本设计思路

整个架构位于包`cn.nukkit.entity.ai`下：

![ENTITY-AI-PKG](%relativePrefix%image/common/entity-ai/entity-ai-pkg.png)

在开始分析源码之前，笔者想先简单阐述下整个架构的设计思路

### 行为组
我们以羊为例，一只完整的羊拥有以下行为：

- 看向最近玩家
- 随机漫游
- 受到伤害时逃跑
- 跑向手里拿着小麦的玩家
- 吃草
- 交配

当然不难想到，我们可以将一只羊抽象成一个“行为组”,其由多个行为组成

### 行为优先级
理解到这点后，我们继续往下思考：对于一个正在执行的行为，它可以被一些行为打断，但不能被另一些行为打断。

我们举个例子，当一只羊发现它身边有拿着小麦的玩家时，它应该中断`随机漫游`行为，并切换到`跑向手里拿着小麦的玩家`行为。

然而如果这个拿着小麦的玩家攻击了这只羊，那么这只羊就应该停止跑向它并开始逃跑，也就是中断`跑向手里拿着小麦的玩家`并切换到`受到伤害时逃跑`行为

于是我们引入了行为优先级的概念，高优先级的行为可以中断低优先级的行为。以优先级从高到低重新排序后的羊行为列表如下:

- 受到伤害时逃跑
- 交配
- 跑向手里拿着小麦的玩家
- 吃草
- 看向最近玩家 & 随机漫游

你也许会疑惑为什么最后一行会同时存在`看向最近玩家`和`随机漫游`行为，事实上这两个行为的优先级是相同的，羊当然可以在漫游的同时看向最近的玩家，它们互不干扰。

### 对于单个行为
对于一个特定的行为，我们希望它能在恰当的时间开始生效，并在恰当的时间停止

事实上，一个行为由一个`评估器`和一个`执行器`组成，`评估器`负责检查当前是否应该激活行为，而`执行器`则负责进行具体的游戏内容以及决定何时停止行为

### 生物记忆和传感器
很多时候，生物的行为取决于外界，例如羊需要寻找距离最近的手里拿着小麦的玩家，需要记录攻击它的玩家和攻击时间，需要在吃草前先检查脚底是否有草可吃

于是我们很自然的引入了`传感器`和`记忆`的概念，传感器负责从外界收集信息，并以单个记忆的形式将收集到的信息写入实体的`记忆存储器`

当然，并不是所有的记忆都是由传感器主动写入的，实体也可以被动接受记忆，例如当玩家攻击实体时，会调用Entity::attack()方法，在此方法中会向实体写入包含攻击者和攻击时间的记忆，注意此时实体是被动接受的，而不是由传感器主动写入。

行为可以通过读取实体记忆来获得信息

### 小结

在这一节中我们初步了解了整个AI框架，在下一节中我们将结合源码深入探索
# 第二章 记忆 - 实体的海马体

_**author: daoge_cmd**_

## 1.0 记忆类型和记忆存储器

对于一个生物来说，不仅存在行为逻辑，在其生命周期中也具有一些实时数据。举个例子，对于羊来说，若其发现附近有手中拿着小麦的玩家并尝试移动过去，其“脑海”中就应该存储着对应此玩家的“记忆”。再比如说对于僵尸，其如果想要攻击最近的玩家，首先需要向“脑海”写入对应此玩家的记忆。这样子寻路器，攻击执行器，控制器等组件才能根据数据正常工作并实现目标行为

我们称上述的每个“数据”为一个记忆类型```MemoryType```。其中羊对应的记忆就是```NEAREST_FEEDING_PLAYER```（最近喂食玩家），僵尸对应的就是```ATTACK_TARGET```（仇恨目标）

"脑海"即记忆存储器```MemoryStorage```，其的概念比较好理解，每个实例化实体都拥有一个独立的记忆存储器，实体的所有记忆都保存在记忆存储器里面

### 1.0.1 创建一个新的记忆类型

MemoryType的可用构造函数如下: 

![](%relativePrefix%image/common/entity-ai/22c4fc46.png)

想要新建一个记忆，我们需要提供一个命名空间标识符```Identifier```以及记忆默认值（当尝试从存储器获取不存在的记忆的值时会返回默认值，可以是常量，也可以通过提供```Supplier<Data>```动态生成）

命名空间标识符是每个记忆类型的“身份证”。PNX核心内部使用的命名空间是```minecraft:```，若你想在插件中增加新的记忆类型，请使用不同于```minecraft:```的命名空间避免重复

核心使用到的所有记忆类型保存在接口```cn.nukkit.entity.ai.memory.CoreMemoryTypes```

## 1.1.0 为什么要这样设计

你可能觉得这样子真的是多此一举，为什么不直接在类中创建新的属性表达“记忆”呢？（事实上笔者最开始的设计就不包含此设定）然而记忆以及记忆存储器的设计在后来的使用中被证明十分有用

### 1.1.1 动态性

思考一下，如果我们不采用记忆存储器保存"仇恨目标"要怎么做？我们就需要设计一个接口叫做```AttackTargetEntity```并要求在使用到”仇恨目标“的实体上实现此接口的```getter```和```setter```方法。

很显然，这太麻烦了。 并且最致命的是，我们失去了动态性：举个例子，若这么做，像是```MeleeAttackExecutor```之类的使用到“仇恨目标”的行为（以至于控制器，寻路器等其他组件）就需要在逻辑中使用```instanceof```并向下转型以获取数据，
我们同时还失去了运行时动态添加行为的能力（例如我们想将僵尸的近战攻击行为动态添加到实例化的羊，但是羊并没有实现```MeleeAttackExecutor```）。事实上，使用接口方法在动态性上的影响远不止这些并无法一一罗列

### 1.1.2 通用性

对于不同实体使用到的含义相同的属性（例如仇恨目标），我们就可以让他们使用相同的记忆类型。举个例子，如果我们想让僵尸去攻击苦力怕，我们就可以将他们的”仇恨目标“分别设置为对方。

使用接口方法确实也可以做到，但是我们需要多一步向下转型。并且与上面相同的是，我们失去了运行时动态添加行为的能力

### 1.1.3 桥梁 - 连接不同组件

事实上，记忆存储器不仅为行为提供信息，它还在组件间发挥了桥梁作用。例如默认的几个运动控制器就通过读取```MOVE_DIRECTION_START```、```MOVE_DIRECTION_END```等记忆移动实体，寻路器通过读取```MOVE_TARGET```计算路径。

通过记忆存储器，不同的简单组件被无缝衔接到了一起，实现了实体的复杂行为